# Firestore Database Schema - Wutzup

## Overview

This document defines the complete Firestore database schema for the Wutzup messaging application.

**Database Type:** Cloud Firestore (NoSQL)  
**Real-Time:** Yes (via Firestore listeners)  
**Offline Support:** Built-in with Firestore offline persistence

---

## Collections Structure

```
firestore/
├── users/                          # User profiles
│   └── {userId}/
│       ├── id: string
│       ├── email: string
│       ├── displayName: string
│       ├── profileImageUrl?: string
│       ├── fcmToken?: string
│       ├── createdAt: timestamp
│       ├── lastSeen?: timestamp
│       ├── personality?: string
│       ├── primaryLanguageCode?: string
│       ├── learningLanguageCode?: string
│       └── isTutor: boolean
│
├── conversations/                  # Chat conversations
│   └── {conversationId}/
│       ├── id: string
│       ├── participantIds: string[]
│       ├── isGroup: boolean
│       ├── groupName?: string
│       ├── groupImageUrl?: string
│       ├── lastMessage?: string
│       ├── lastMessageTimestamp?: timestamp
│       ├── createdAt: timestamp
│       ├── updatedAt: timestamp
│       │
│       └── messages/               # Messages subcollection
│           └── {messageId}/
│               ├── id: string
│               ├── senderId: string
│               ├── content: string
│               ├── timestamp: timestamp
│               ├── mediaUrl?: string
│               ├── mediaType?: 'image' | 'video'
│               ├── readBy: string[]
│               └── deliveredTo: string[]
│
├── presence/                       # User presence/status
│   └── {userId}/
│       ├── status: 'online' | 'offline'
│       ├── lastSeen: timestamp
│       └── typing: map<conversationId, boolean>
│
└── typing/                         # Typing indicators (ephemeral)
    └── {conversationId}/
        └── users: map<userId, timestamp>
```

---

## Collection Details

### 1. Users Collection

**Path:** `/users/{userId}`  
**Document ID:** Firebase Auth UID

#### Schema

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `id` | string | Yes | User ID (must match document ID) |
| `email` | string | Yes | User's email address |
| `displayName` | string | Yes | User's display name |
| `profileImageUrl` | string | No | URL to user's profile picture (Firebase Storage) |
| `fcmToken` | string | No | Firebase Cloud Messaging token for push notifications |
| `createdAt` | timestamp | Yes | Account creation timestamp |
| `lastSeen` | timestamp | No | Last time user was active |
| `personality` | string | No | User's personality description (for AI interactions) |
| `primaryLanguageCode` | string | No | User's primary language (ISO 639-1 code) |
| `learningLanguageCode` | string | No | Language user is learning (ISO 639-1 code) |
| `isTutor` | boolean | Yes | Whether user is a bot/LLM tutor (default: false) |

#### TypeScript Type

```typescript
interface User {
  id: string;                    // Document ID (Firebase Auth UID)
  email: string;
  displayName: string;
  profileImageUrl?: string;
  fcmToken?: string;
  createdAt: FirebaseFirestore.Timestamp;
  lastSeen?: FirebaseFirestore.Timestamp;
  personality?: string;
  primaryLanguageCode?: string;
  learningLanguageCode?: string;
  isTutor: boolean;              // Whether user is a bot/LLM tutor
}
```

#### Python Type

```python
from typing import TypedDict, Optional
from google.cloud.firestore import SERVER_TIMESTAMP

class User(TypedDict):
    id: str
    email: str
    displayName: str
    profileImageUrl: Optional[str]
    fcmToken: Optional[str]
    createdAt: SERVER_TIMESTAMP
    lastSeen: Optional[SERVER_TIMESTAMP]
    personality: Optional[str]
    primaryLanguageCode: Optional[str]
    learningLanguageCode: Optional[str]
    isTutor: bool
```

#### Example Document

```json
{
  "id": "user_abc123",
  "email": "alice@example.com",
  "displayName": "Alice Smith",
  "profileImageUrl": "https://storage.googleapis.com/wutzup/users/user_abc123.jpg",
  "fcmToken": "fcm_token_xyz",
  "createdAt": "2025-10-21T10:00:00Z",
  "lastSeen": "2025-10-21T15:30:00Z",
  "personality": "Friendly and helpful",
  "primaryLanguageCode": "en",
  "learningLanguageCode": "es",
  "isTutor": false
}
```

#### Queries

```typescript
// Get user by ID
const userRef = db.collection('users').doc(userId);
const user = await userRef.get();

// Search users by display name (requires full-text search or Algolia)
const usersRef = db.collection('users')
  .where('displayName', '>=', searchTerm)
  .where('displayName', '<=', searchTerm + '\uf8ff')
  .limit(20);
```

---

### 2. Conversations Collection

**Path:** `/conversations/{conversationId}`  
**Document ID:** Auto-generated by Firestore

#### Schema

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `id` | string | Yes | Conversation ID (must match document ID) |
| `participantIds` | string[] | Yes | Array of user IDs (min 2) |
| `participantNames` | map | Yes | Map of userId -> displayName for quick access |
| `isGroup` | boolean | Yes | True if 3+ participants |
| `groupName` | string | No | Group chat name (required if isGroup) |
| `groupImageUrl` | string | No | Group chat image URL |
| `lastMessage` | string | No | Preview of last message |
| `lastMessageTimestamp` | timestamp | No | Timestamp of last message |
| `createdAt` | timestamp | Yes | Conversation creation timestamp |
| `updatedAt` | timestamp | Yes | Last update timestamp |
| `unreadCount` | number | Yes | Count of unread messages for the conversation |

#### TypeScript Type

```typescript
interface Conversation {
  id: string;                    // Document ID
  participantIds: string[];      // Min 2 users
  participantNames: { [userId: string]: string };  // userId -> displayName
  isGroup: boolean;              // true if participantIds.length > 2
  groupName?: string;
  groupImageUrl?: string;
  lastMessage?: string;
  lastMessageTimestamp?: FirebaseFirestore.Timestamp;
  createdAt: FirebaseFirestore.Timestamp;
  updatedAt: FirebaseFirestore.Timestamp;
  unreadCount: number;           // Count of unread messages
}
```

#### Python Type

```python
from typing import TypedDict, Optional, List, Dict

class Conversation(TypedDict):
    id: str
    participantIds: List[str]
    participantNames: Dict[str, str]  # userId -> displayName
    isGroup: bool
    groupName: Optional[str]
    groupImageUrl: Optional[str]
    lastMessage: Optional[str]
    lastMessageTimestamp: Optional[SERVER_TIMESTAMP]
    createdAt: SERVER_TIMESTAMP
    updatedAt: SERVER_TIMESTAMP
    unreadCount: int
```

#### Example Document

```json
{
  "id": "conv_xyz789",
  "participantIds": ["user_abc123", "user_def456"],
  "participantNames": {
    "user_abc123": "Alice Smith",
    "user_def456": "Bob Jones"
  },
  "isGroup": false,
  "lastMessage": "Hey! How are you?",
  "lastMessageTimestamp": "2025-10-21T15:30:00Z",
  "createdAt": "2025-10-20T10:00:00Z",
  "updatedAt": "2025-10-21T15:30:00Z",
  "unreadCount": 0
}
```

#### Queries

```typescript
// Get all conversations for a user (ordered by last message)
const conversationsRef = db.collection('conversations')
  .where('participantIds', 'array-contains', userId)
  .orderBy('lastMessageTimestamp', 'desc')
  .limit(50);

// Listen to conversations in real-time
conversationsRef.onSnapshot(snapshot => {
  snapshot.docChanges().forEach(change => {
    if (change.type === 'added') {
      console.log('New conversation:', change.doc.data());
    }
  });
});
```

---

### 3. Messages Subcollection

**Path:** `/conversations/{conversationId}/messages/{messageId}`  
**Document ID:** Auto-generated by Firestore

#### Schema

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `id` | string | Yes | Message ID (must match document ID) |
| `senderId` | string | Yes | User ID of sender |
| `content` | string | Yes | Message text content (max 10KB) |
| `timestamp` | timestamp | Yes | Message creation timestamp |
| `mediaUrl` | string | No | URL to media file (Firebase Storage) |
| `mediaType` | string | No | 'image' or 'video' |
| `readBy` | string[] | Yes | Array of user IDs who read the message |
| `deliveredTo` | string[] | Yes | Array of user IDs who received the message |

#### TypeScript Type

```typescript
interface Message {
  id: string;                    // Document ID
  senderId: string;              // User ID
  content: string;               // Max 10KB
  timestamp: FirebaseFirestore.Timestamp;
  mediaUrl?: string;
  mediaType?: 'image' | 'video';
  readBy: string[];              // User IDs
  deliveredTo: string[];         // User IDs
}
```

#### Python Type

```python
from typing import TypedDict, Optional, List, Literal

class Message(TypedDict):
    id: str
    senderId: str
    content: str
    timestamp: SERVER_TIMESTAMP
    mediaUrl: Optional[str]
    mediaType: Optional[Literal['image', 'video']]
    readBy: List[str]
    deliveredTo: List[str]
```

#### Example Document

```json
{
  "id": "msg_123abc",
  "senderId": "user_abc123",
  "content": "Hey! How are you?",
  "timestamp": "2025-10-21T15:30:00Z",
  "readBy": ["user_abc123", "user_def456"],
  "deliveredTo": ["user_abc123", "user_def456"]
}
```

#### Queries

```typescript
// Get messages for a conversation (ordered by timestamp)
const messagesRef = db.collection('conversations')
  .doc(conversationId)
  .collection('messages')
  .orderBy('timestamp', 'asc')
  .limit(50);

// Listen to new messages in real-time
messagesRef.onSnapshot(snapshot => {
  snapshot.docChanges().forEach(change => {
    if (change.type === 'added') {
      console.log('New message:', change.doc.data());
    }
  });
});

// Pagination: Get next page of messages
const nextMessagesRef = db.collection('conversations')
  .doc(conversationId)
  .collection('messages')
  .orderBy('timestamp', 'desc')
  .startAfter(lastMessageTimestamp)
  .limit(50);
```

---

### 4. Presence Collection

**Path:** `/presence/{userId}`  
**Document ID:** User ID (Firebase Auth UID)

#### Schema

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `status` | string | Yes | 'online' or 'offline' |
| `lastSeen` | timestamp | Yes | Last activity timestamp |
| `typing` | map | No | Map of conversationId → boolean |

#### TypeScript Type

```typescript
interface Presence {
  status: 'online' | 'offline';
  lastSeen: FirebaseFirestore.Timestamp;
  typing?: { [conversationId: string]: boolean };
}
```

#### Python Type

```python
from typing import TypedDict, Optional, Dict, Literal

class Presence(TypedDict):
    status: Literal['online', 'offline']
    lastSeen: SERVER_TIMESTAMP
    typing: Optional[Dict[str, bool]]
```

#### Example Document

```json
{
  "status": "online",
  "lastSeen": "2025-10-21T15:30:00Z",
  "typing": {
    "conv_xyz789": true
  }
}
```

#### Queries

```typescript
// Listen to user presence
const presenceRef = db.collection('presence').doc(userId);
presenceRef.onSnapshot(snapshot => {
  const presence = snapshot.data();
  console.log('User status:', presence.status);
});

// Update user status
await db.collection('presence').doc(userId).set({
  status: 'online',
  lastSeen: FieldValue.serverTimestamp()
}, { merge: true });
```

---

### 5. Typing Collection

**Path:** `/typing/{conversationId}`  
**Document ID:** Conversation ID

#### Schema

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `users` | map | Yes | Map of userId → timestamp |

#### TypeScript Type

```typescript
interface TypingIndicator {
  users: { [userId: string]: FirebaseFirestore.Timestamp };
}
```

#### Python Type

```python
from typing import TypedDict, Dict

class TypingIndicator(TypedDict):
    users: Dict[str, SERVER_TIMESTAMP]
```

#### Example Document

```json
{
  "users": {
    "user_abc123": "2025-10-21T15:30:00Z"
  }
}
```

#### Queries

```typescript
// Listen to typing indicators
const typingRef = db.collection('typing').doc(conversationId);
typingRef.onSnapshot(snapshot => {
  const typing = snapshot.data()?.users || {};
  const typingUserIds = Object.keys(typing);
  console.log('Users typing:', typingUserIds);
});

// Set typing indicator
await db.collection('typing').doc(conversationId).set({
  users: {
    [userId]: FieldValue.serverTimestamp()
  }
}, { merge: true });

// Clear typing indicator
await db.collection('typing').doc(conversationId).update({
  [`users.${userId}`]: FieldValue.delete()
});
```

---

## Indexes

### Conversations Index

**Purpose:** Query user's conversations ordered by last message timestamp

```json
{
  "collectionGroup": "conversations",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "participantIds", "arrayConfig": "CONTAINS" },
    { "fieldPath": "lastMessageTimestamp", "order": "DESCENDING" }
  ]
}
```

### Messages Index (Ascending)

**Purpose:** Query messages in chronological order (for chat display)

```json
{
  "collectionGroup": "messages",
  "queryScope": "COLLECTION_GROUP",
  "fields": [
    { "fieldPath": "timestamp", "order": "ASCENDING" }
  ]
}
```

### Messages Index (Descending)

**Purpose:** Query messages in reverse chronological order (for pagination)

```json
{
  "collectionGroup": "messages",
  "queryScope": "COLLECTION_GROUP",
  "fields": [
    { "fieldPath": "timestamp", "order": "DESCENDING" }
  ]
}
```

### Messages by Sender Index

**Purpose:** Query messages by sender and timestamp

```json
{
  "collectionGroup": "messages",
  "queryScope": "COLLECTION_GROUP",
  "fields": [
    { "fieldPath": "senderId", "order": "ASCENDING" },
    { "fieldPath": "timestamp", "order": "DESCENDING" }
  ]
}
```

---

## Security Rules Summary

### Users
- ✅ Read: Any authenticated user
- ✅ Create: Owner only (on registration)
- ✅ Update: Owner only
- ❌ Delete: Not allowed (use Cloud Functions)

### Conversations
- ✅ Read: Participants only
- ✅ Create: Creator must be participant
- ✅ Update: Participants only (can't change participants)
- ❌ Delete: Not allowed (use Cloud Functions)

### Messages
- ✅ Read: Conversation participants only
- ✅ Create: Participant only (must be sender)
- ✅ Update: Participants only (for read receipts)
- ❌ Delete: Not allowed (MVP)

### Presence
- ✅ Read: Any authenticated user
- ✅ Write: Owner only

### Typing
- ✅ Read: Any authenticated user
- ✅ Write: Any authenticated user

---

## Data Flow Patterns

### Creating a User

```typescript
// 1. Create Firebase Auth user
const credential = await createUserWithEmailAndPassword(auth, email, password);

// 2. Create Firestore user document
await db.collection('users').doc(credential.user.uid).set({
  id: credential.user.uid,
  email: email,
  displayName: displayName,
  createdAt: FieldValue.serverTimestamp()
});
```

### Creating a Conversation

```typescript
// 1. Create conversation document
const conversationRef = db.collection('conversations').doc();
await conversationRef.set({
  id: conversationRef.id,
  participantIds: [currentUserId, otherUserId],
  isGroup: false,
  createdAt: FieldValue.serverTimestamp(),
  updatedAt: FieldValue.serverTimestamp()
});
```

### Sending a Message

```typescript
// 1. Create message document
const messageRef = db.collection('conversations')
  .doc(conversationId)
  .collection('messages')
  .doc();

await messageRef.set({
  id: messageRef.id,
  senderId: currentUserId,
  content: messageContent,
  timestamp: FieldValue.serverTimestamp(),
  readBy: [currentUserId],
  deliveredTo: [currentUserId]
});

// 2. Update conversation's lastMessage
await db.collection('conversations').doc(conversationId).update({
  lastMessage: messageContent,
  lastMessageTimestamp: FieldValue.serverTimestamp(),
  updatedAt: FieldValue.serverTimestamp()
});

// 3. Cloud Function sends push notification automatically
```

### Marking Message as Read

```typescript
await db.collection('conversations')
  .doc(conversationId)
  .collection('messages')
  .doc(messageId)
  .update({
    readBy: FieldValue.arrayUnion(currentUserId)
  });
```

---

## Best Practices

### 1. Use Server Timestamps

Always use `FieldValue.serverTimestamp()` instead of client timestamps to avoid clock skew.

```typescript
// ✅ Good
await ref.set({ createdAt: FieldValue.serverTimestamp() });

// ❌ Bad
await ref.set({ createdAt: new Date() });
```

### 2. Batch Writes

Use batched writes for atomic operations.

```typescript
const batch = db.batch();
batch.set(messageRef, messageData);
batch.update(conversationRef, { lastMessage: content });
await batch.commit();
```

### 3. Pagination

Use `startAfter()` for efficient pagination.

```typescript
const firstPage = await messagesRef.orderBy('timestamp').limit(50).get();
const lastVisible = firstPage.docs[firstPage.docs.length - 1];

const nextPage = await messagesRef
  .orderBy('timestamp')
  .startAfter(lastVisible)
  .limit(50)
  .get();
```

### 4. Real-Time Listeners

Always clean up listeners to avoid memory leaks.

```typescript
const unsubscribe = messagesRef.onSnapshot(snapshot => {
  // Handle updates
});

// Later
unsubscribe();
```

### 5. Error Handling

Always handle Firestore errors.

```typescript
try {
  await db.collection('users').doc(userId).get();
} catch (error) {
  if (error.code === 'permission-denied') {
    console.error('Access denied');
  } else if (error.code === 'unavailable') {
    console.error('Firestore unavailable');
  }
}
```

---

## Migration Notes

### From Custom Backend

If migrating from a custom backend:

1. Export data from PostgreSQL
2. Transform to Firestore format (flat structure, denormalized)
3. Import using Firestore Admin SDK
4. Test security rules with emulator
5. Deploy indexes first
6. Deploy security rules
7. Switch client apps to Firestore

### Data Denormalization

Firestore works best with denormalized data. For example:

- Store `lastMessage` in conversation document (don't fetch from messages)
- Store user `displayName` in messages for quick display (don't join with users)
- Use array fields (`readBy`, `deliveredTo`) instead of join tables

---

## Performance Tips

1. **Limit Query Results**: Always use `.limit()` on queries
2. **Use Indexes**: Define composite indexes for complex queries
3. **Cache Locally**: Use SwiftData to cache Firestore data
4. **Batch Reads**: Read multiple documents in one call
5. **Avoid Document Scans**: Use indexed fields in `where()` clauses

---

## Cost Optimization

1. **Cache Aggressively**: Reduce read operations with local cache
2. **Batch Writes**: Combine multiple writes into one batch
3. **Limit Listeners**: Only listen to active conversations
4. **Archive Old Messages**: Move old messages to cheaper storage
5. **Set Budget Alerts**: Monitor Firestore usage in Firebase console

---

**Last Updated:** October 24, 2025

